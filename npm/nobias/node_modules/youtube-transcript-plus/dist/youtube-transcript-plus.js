import fs from 'fs/promises';
import path from 'path';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';
const RE_YOUTUBE = /(?:v=|\/|v\/|embed\/|watch\?.*v=|youtu\.be\/|\/v\/|e\/|watch\?.*vi?=|\/embed\/|\/v\/|vi?\/|watch\?.*vi?=|youtu\.be\/|\/vi?\/|\/e\/)([a-zA-Z0-9_-]{11})/i;
const RE_XML_TRANSCRIPT = /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g;
const DEFAULT_CACHE_TTL = 3600000; // 1 hour in milliseconds

class YoutubeTranscriptTooManyRequestError extends Error {
    constructor() {
        super('YouTube is receiving too many requests from your IP address. Please try again later or use a proxy. If the issue persists, consider reducing the frequency of requests.');
        this.name = 'YoutubeTranscriptTooManyRequestError';
    }
}
class YoutubeTranscriptVideoUnavailableError extends Error {
    constructor(videoId) {
        super(`The video with ID "${videoId}" is no longer available or has been removed. Please check the video URL or ID and try again.`);
        this.name = 'YoutubeTranscriptVideoUnavailableError';
    }
}
class YoutubeTranscriptDisabledError extends Error {
    constructor(videoId) {
        super(`Transcripts are disabled for the video with ID "${videoId}". This may be due to the video owner disabling captions or the video not supporting transcripts.`);
        this.name = 'YoutubeTranscriptDisabledError';
    }
}
class YoutubeTranscriptNotAvailableError extends Error {
    constructor(videoId) {
        super(`No transcripts are available for the video with ID "${videoId}". This may be because the video does not have captions or the captions are not accessible.`);
        this.name = 'YoutubeTranscriptNotAvailableError';
    }
}
class YoutubeTranscriptNotAvailableLanguageError extends Error {
    constructor(lang, availableLangs, videoId) {
        super(`No transcripts are available in "${lang}" for the video with ID "${videoId}". Available languages: ${availableLangs.join(', ')}. Please try a different language.`);
        this.name = 'YoutubeTranscriptNotAvailableLanguageError';
    }
}
class YoutubeTranscriptInvalidVideoIdError extends Error {
    constructor() {
        super('Invalid YouTube video ID or URL. Please provide a valid video ID or URL. Example: "dQw4w9WgXcQ" or "https://www.youtube.com/watch?v=dQw4w9WgXcQ".');
        this.name = 'YoutubeTranscriptInvalidVideoIdError';
    }
}

function retrieveVideoId(videoId) {
    if (videoId.length === 11) {
        return videoId;
    }
    const matchId = videoId.match(RE_YOUTUBE);
    if (matchId && matchId.length) {
        return matchId[1];
    }
    throw new YoutubeTranscriptInvalidVideoIdError();
}
function defaultFetch(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, lang, userAgent, method = 'GET', body, headers = {} } = params;
        const fetchHeaders = Object.assign(Object.assign({ 'User-Agent': userAgent || DEFAULT_USER_AGENT }, (lang && { 'Accept-Language': lang })), headers);
        const fetchOptions = {
            method,
            headers: fetchHeaders,
        };
        if (body && method === 'POST') {
            fetchOptions.body = body;
        }
        return fetch(url, fetchOptions);
    });
}

class FsCache {
    constructor(cacheDir = './cache', defaultTTL = DEFAULT_CACHE_TTL) {
        this.cacheDir = cacheDir;
        this.defaultTTL = defaultTTL;
        fs.mkdir(cacheDir, { recursive: true }).catch(() => { });
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.cacheDir, key);
            try {
                const data = yield fs.readFile(filePath, 'utf-8');
                const { value, expires } = JSON.parse(data);
                if (expires > Date.now()) {
                    return value;
                }
                yield fs.unlink(filePath);
            }
            catch (error) { }
            return null;
        });
    }
    set(key, value, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.cacheDir, key);
            const expires = Date.now() + (ttl !== null && ttl !== void 0 ? ttl : this.defaultTTL);
            yield fs.writeFile(filePath, JSON.stringify({ value, expires }), 'utf-8');
        });
    }
}

class InMemoryCache {
    constructor(defaultTTL = DEFAULT_CACHE_TTL) {
        this.cache = new Map();
        this.defaultTTL = defaultTTL;
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const entry = this.cache.get(key);
            if (entry && entry.expires > Date.now()) {
                return entry.value;
            }
            this.cache.delete(key); // Clean up expired entries
            return null;
        });
    }
    set(key, value, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            const expires = Date.now() + (ttl !== null && ttl !== void 0 ? ttl : this.defaultTTL);
            this.cache.set(key, { value, expires });
        });
    }
}

/**
 * Implementation notes:
 * - Keeps the public surface identical.
 * - Internals now use YouTube Innertube `player` to discover captionTracks instead of scraping the watch HTML.
 * - Honors `lang`, custom fetch hooks (`videoFetch`, `transcriptFetch`), and optional cache strategy.
 */
class YoutubeTranscript {
    constructor(config) {
        this.config = config;
    }
    fetchTranscript(videoId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            const identifier = retrieveVideoId(videoId);
            const lang = (_a = this.config) === null || _a === void 0 ? void 0 : _a.lang;
            const userAgent = (_c = (_b = this.config) === null || _b === void 0 ? void 0 : _b.userAgent) !== null && _c !== void 0 ? _c : DEFAULT_USER_AGENT;
            // Cache lookup (if provided)
            const cache = (_d = this.config) === null || _d === void 0 ? void 0 : _d.cache;
            const cacheTTL = (_e = this.config) === null || _e === void 0 ? void 0 : _e.cacheTTL;
            const cacheKey = `yt:transcript:${identifier}:${lang !== null && lang !== void 0 ? lang : ''}`;
            if (cache) {
                const cached = yield cache.get(cacheKey);
                if (cached) {
                    try {
                        return JSON.parse(cached);
                    }
                    catch (_p) {
                        // ignore parse errors and continue
                    }
                }
            }
            // 1) Fetch the watch page to extract an Innertube API key (no interface change)
            // Decide protocol once and reuse
            const protocol = ((_f = this.config) === null || _f === void 0 ? void 0 : _f.disableHttps) ? 'http' : 'https';
            const watchUrl = `${protocol}://www.youtube.com/watch?v=${identifier}`;
            const videoPageResponse = ((_g = this.config) === null || _g === void 0 ? void 0 : _g.videoFetch)
                ? yield this.config.videoFetch({ url: watchUrl, lang, userAgent })
                : yield defaultFetch({ url: watchUrl, lang, userAgent });
            if (!videoPageResponse.ok) {
                throw new YoutubeTranscriptVideoUnavailableError(identifier);
            }
            const videoPageBody = yield videoPageResponse.text();
            // Basic bot/recaptcha detection preserves old error behavior
            if (videoPageBody.includes('class="g-recaptcha"')) {
                throw new YoutubeTranscriptTooManyRequestError();
            }
            // 2) Extract Innertube API key from the page
            const apiKeyMatch = videoPageBody.match(/"INNERTUBE_API_KEY":"([^"]+)"/) ||
                videoPageBody.match(/INNERTUBE_API_KEY\\":\\"([^\\"]+)\\"/);
            if (!apiKeyMatch) {
                // If captions JSON wasn't present previously and we also can't find an API key,
                // retain the disabled semantics for compatibility.
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            const apiKey = apiKeyMatch[1];
            // 3) Call Innertube player as ANDROID client to retrieve captionTracks
            const playerEndpoint = `https://www.youtube.com/youtubei/v1/player?key=${apiKey}`;
            const playerBody = {
                context: {
                    client: {
                        clientName: 'ANDROID',
                        clientVersion: '20.10.38',
                    },
                },
                videoId: identifier,
            };
            // Use configurable playerFetch for the POST to allow custom fetch logic.
            const playerFetchParams = {
                url: playerEndpoint,
                method: 'POST',
                lang,
                userAgent,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(playerBody),
            };
            const playerRes = ((_h = this.config) === null || _h === void 0 ? void 0 : _h.playerFetch)
                ? yield this.config.playerFetch(playerFetchParams)
                : yield defaultFetch(playerFetchParams);
            if (!playerRes.ok) {
                throw new YoutubeTranscriptVideoUnavailableError(identifier);
            }
            const playerJson = yield playerRes.json();
            const tracklist = (_k = (_j = playerJson === null || playerJson === void 0 ? void 0 : playerJson.captions) === null || _j === void 0 ? void 0 : _j.playerCaptionsTracklistRenderer) !== null && _k !== void 0 ? _k : playerJson === null || playerJson === void 0 ? void 0 : playerJson.playerCaptionsTracklistRenderer;
            const tracks = tracklist === null || tracklist === void 0 ? void 0 : tracklist.captionTracks;
            const isPlayableOk = ((_l = playerJson === null || playerJson === void 0 ? void 0 : playerJson.playabilityStatus) === null || _l === void 0 ? void 0 : _l.status) === 'OK';
            // If `captions` is entirely missing, treat as "not available"
            if (!(playerJson === null || playerJson === void 0 ? void 0 : playerJson.captions) || !tracklist) {
                // If video is playable but captions aren’t provided, treat as "disabled"
                if (isPlayableOk) {
                    throw new YoutubeTranscriptDisabledError(identifier);
                }
                // Otherwise we can’t assert they’re disabled; treat as "not available"
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            // If `captions` exists but there are zero tracks, treat as "disabled"
            if (!Array.isArray(tracks) || tracks.length === 0) {
                throw new YoutubeTranscriptDisabledError(identifier);
            }
            // Respect requested language or fallback to first track
            const selectedTrack = lang ? tracks.find((t) => t.languageCode === lang) : tracks[0];
            if (!selectedTrack) {
                const available = tracks.map((t) => t.languageCode).filter(Boolean);
                throw new YoutubeTranscriptNotAvailableLanguageError(lang, available, identifier);
            }
            // 4) Build transcript URL; prefer XML by stripping fmt if present
            let transcriptURL = selectedTrack.baseUrl || selectedTrack.url;
            if (!transcriptURL) {
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            transcriptURL = transcriptURL.replace(/&fmt=[^&]+$/, '');
            if ((_m = this.config) === null || _m === void 0 ? void 0 : _m.disableHttps) {
                transcriptURL = transcriptURL.replace(/^https:\/\//, 'http://');
            }
            // 5) Fetch transcript XML using the same hook surface as before
            const transcriptResponse = ((_o = this.config) === null || _o === void 0 ? void 0 : _o.transcriptFetch)
                ? yield this.config.transcriptFetch({ url: transcriptURL, lang, userAgent })
                : yield defaultFetch({ url: transcriptURL, lang, userAgent });
            if (!transcriptResponse.ok) {
                // Preserve legacy behavior
                if (transcriptResponse.status === 429) {
                    throw new YoutubeTranscriptTooManyRequestError();
                }
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            const transcriptBody = yield transcriptResponse.text();
            // 6) Parse XML into the existing TranscriptResponse shape
            const results = [...transcriptBody.matchAll(RE_XML_TRANSCRIPT)];
            const transcript = results.map((m) => ({
                text: m[3],
                duration: parseFloat(m[2]),
                offset: parseFloat(m[1]),
                lang: lang !== null && lang !== void 0 ? lang : selectedTrack.languageCode,
            }));
            if (transcript.length === 0) {
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            // Cache store
            if (cache) {
                try {
                    yield cache.set(cacheKey, JSON.stringify(transcript), cacheTTL);
                }
                catch (_q) {
                    // non-fatal
                }
            }
            return transcript;
        });
    }
    static fetchTranscript(videoId, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new YoutubeTranscript(config);
            return instance.fetchTranscript(videoId);
        });
    }
}
// Export the static method directly for convenience
const fetchTranscript = YoutubeTranscript.fetchTranscript;

export { FsCache, InMemoryCache, YoutubeTranscript, YoutubeTranscriptDisabledError, YoutubeTranscriptInvalidVideoIdError, YoutubeTranscriptNotAvailableError, YoutubeTranscriptNotAvailableLanguageError, YoutubeTranscriptTooManyRequestError, YoutubeTranscriptVideoUnavailableError, fetchTranscript };
